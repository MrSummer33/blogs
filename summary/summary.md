### 1.junit用法，before,beforeClass,after, afterClass的执行顺序
```
执行顺序：beforeClass -> before -> test -> after -> afterClass
* beforeClass:类加载的时候触发
* before:初始化的时候触发
* test:真正执行的测试逻辑
* after:类GC时触发
* afterClass:类卸载时触发
```
#### 静态初始化方法和实例初始化方法区别
```
* 静态初始化方法：一般实例化全局的静态变量
* 实例初始化方法：用于初始化实例
```
### 2.分布式锁
```
- 锁
	排他性
	阻塞/非阻塞
	可重入锁
	避免死锁
- 分布式锁
	确保分布式情况下，同时只有一个线程能够对某对象进行操作
- 要素
	集中锁管理组件，使其在分布式系统间协调，确保同时只有一个线程能获取锁
- 实现
	1.数据库唯一索引
	2.redis
	3.zookeeper
```
#### redis实现分布式锁
```
- redis实现
	获取锁:set key 
	释放锁:del key
	容错:redis集群
		Redlock
			- 1:获取当前时间戳
			- 2:到redis集群中去获取锁
			- 3:只有大部分节点set成功，切获取锁时间小于TTL则算获取成功，
			- 4:获取成功，执行操作   注意可执行的时间
			- 5:获取失败，释放所有set成功的节点
	身份验证
		value上唯一标示
	重试
		获取锁失败,采用随机间隔重试
	宕机
		数据恢复的情况
	由于超时释放锁导致的不互斥原因
		1.设置适当的超时时间
		2.设置获取锁的时间
```
[REDIS 分布式锁官方文档](http://ifeve.com/redis-lock/)

### 3.NGINX 请求转发策略
```
- 随机轮训
- 权重轮训
- IP HASH
- URL HASH
- 智能调度
	根据后端服务器的压力，动态调整转发权重
```
### 4. 用HashMap实现redis有什么问题
同为key-value形式，

```
- 本地缓存，不支持分布式
- 不支持数据持久化
- 线程不安全，高并发是会出现闭环，导致CPU空转
- 数据量，hashmap基于JVM的，存放的数据量有限
- 缺少数据超时等Redis特性
- 效率等
```

### 5 线程状态
![线程状态](https://github.com/MrSummer33/blogs/blob/master/PICTURES/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.jpg)

```
1.新建
2.可运行
	就绪和运行中都归类为可运行
3.阻塞
4.等待
5.超时等待
6.终止
```

#### 5.1 线程阻塞的方式
```
1.等待同步锁
2.等待IO返回
3.等待RPC返回
```

#### 5.2 sleep()和wait的区别
```
1.sleep是Thread内部方法,wait()是Object中的方法
2.sleep方法不释放对象锁，只释放CPU资源；wait方法同时释放对象锁和CPU资源
3.wait()只有在持有对象锁的情况下才能执行
4.sleep()是静态方法，只能休眠当前线程，注意t.sleep()
5.wait/notify-等待通知机制，可实现线程间通信
```

#### 5.3 sleep和yield的区别
```
sleep让出cpu,休眠一段时间之后才可参与竞争CPU
yield让出CPU,可立即参与竞争CPU
```

#### 5.4 join方法
```
当前线程，等待某线程执行结束
```

#### 5.5 interrupt()
```
1.设置中断标志，具体如何响应由线程自行决定
2.阻塞情况下，一般都会抛出异常
```

#### 5.6 其他
```
1.对象锁的同步队列
2.重入锁的实现方式:记录线程加锁次数
```

### 6. hashmap的底层实现
```
1.数据结构 - 通过hash表来持有数据，通过链表来解决哈希冲突
2.put方法的实现过程
	- 通过哈希值计算数组索引
	- 若位桶为空，直接添加到该位桶
	- 存位桶不为空，通过equals方法遍历链表，若存在相同的key则覆盖，不存在添加到链表尾部
	除此之外还会有
		数组扩容
		链表转红黑树
3.HashMap线程不安全，
	- JDK1.8之前，并发情况下的扩容可能会发生闭环，JDK1.8之后不会。
	JDK1.8之前扩容时，链表会被多线程共同拼接，所以会导致闭环。1.8之后整个链表的拆分放在线程内部执行，不会被其他线程干扰
```

### 7.ConsurrentHashMap 
```
1.数据结构 - 通过hash表来持有数据，通过链表来解决哈希冲突
2.通过分段锁来保证线程安全
3.put操作和HashMap类似
	- 通过哈希值计算哈希表索引
	- 若位桶为空，直接添加
	- 若不为空，则对位桶上锁，判断key是否存在于位桶中，存在，则覆盖，不存在，添加
	- 此时可能会触发
		哈希表扩容
		链表转红黑树
4.并发扩容
	- 当哈希表正在扩容时，当前线程会参与扩容，这样可以提高哈希表扩容的效率。
	- 扩容时，以位桶为单位进行操作，能够保证线程安全。
5.其他
	- 迭代时不会抛出ConcurrentModificationException
	- 弱一致性
```

### 8. 一万个人抢100个红包，如何实现，如何保证2个人不能抢到同一个红包。
```
1.消息队列
	- 将请求迅速放到消息队列中去,通过MQ避免高峰期暴增的流量
2.分布式锁
	- 通过分布式锁，只有获取到锁的线程才能抢红包，否则立即返回
3.获取到分布式锁或消费MQ时，检验数据合法性，1:用户多次抢红包 2:红包个数
```

### 9.秒杀实现方案
[秒杀系统实现方案](https://www.aliyun.com/jiaocheng/547505.html)

```
1.热点数据预热，将热点数据添加到缓存中
2.热点隔离
	业务、系统、数据隔离，将热点数据和普通数据分离处理。避免少量的热点数据影响大量的普通数据
3.动静分离
	前端尽量缓存不变的数据，后端只处理动态变更的数据。
4.前端控制并发量
	1.验证码机制:可适当的削减高峰期流量
	2.防止表单重复提交
	3.检验基本信息合法性
5.后端服务限流
	1.对热点url进行限流保护，sentinel
	2.对用户限流，防止恶意刷单
6.消息队列异步处理
	通过MQ，削峰填谷。避免高峰期流量。
7.分布式锁
	通过分布式锁来控制到达下游业务的流量
8.后端过滤流量
	1.校验数据合法性
	2.检验库存合法
9.容器扩容和服务预热

关键
	1.尽量在上游过滤高峰的流量，控制写操作的数量
	2.写数据做好缓存,尽量省去重复的请求
```

